
# Java Algorithm Solutions

Welcome to the Java Algorithm Solutions repository! Here, you'll find Java implementations of various algorithmic problems, each aimed at enhancing your understanding of data structures, algorithms, and problem-solving skills.

## About This Repository:

This repository serves as a resource for programmers, students, and enthusiasts alike who are interested in learning and practicing algorithmic problem-solving using Java.

The solutions provided here cover a wide range of topics, including array manipulation, linked lists, string manipulation, searching, sorting, and more.

Feel free to explore the solutions, study the implementations, and use them as a reference for your own projects or academic pursuits.

## List of Files:

1. **ArrangeDuplicates.java**: Arrange duplicate elements in an array.
2. **DeleteKthNode.java**: Delete the k-th node from the end of a linked list.
3. **EvenFactPrime.java**: Find even factorial prime numbers.
4. **LongestCommonPrefix.java**: Find the longest common prefix among a set of strings.
5. **LRU_Cache.java**: Implement a Least Recently Used (LRU) cache.
6. **Moves_Zeroes.java**: Move zeroes to the end of an array while maintaining the order of non-zero elements.
7. **RemoveElement.java**: Remove all instances of a given value from an array in-place.
8. **ReverseList.java**: Reverse a singly linked list.
9. **ReverseString.java**: Reverse a given string.
10. **ReverseVowels.java**: Reverse only the vowels in a given string.
11. **SmallestMissingInteger.java**: Find the smallest positive integer missing from an unsorted array.
12. **Sqrt.java**: Find the square root of a given non-negative integer.
13. **Word_Search.java**: Implement the word search algorithm.
14. **Chocolate_Distribution.java**: Implement the chocolate distribution problem, which is based on Kadane's algorithm.
15. **LevelOrderTraversal.java**: Implement the chocolate distribution problem, which is based on a Binary Tree.
16. **DeleteMiddleElementofLinkedList.java**: Implement the delete the middle of element on the LinkedList problem, which is based on the Hare and Tortoise algorithm.
17. **FindMissingNumber.java**: Implement the Missing Number problem, which is based on the xor operation.
18.  **SumDependencyGraph.java**: Implement the sum dependencies problem, which is based on the directed and connected graphs.
19.   **StockBuyAndSell.java**: Implement the stock buy and sell problem, which is based on the array.
20.   **DetectCycleUndirectedGraph.java**: Implement the detect cycle undirected graph problem, which is based on an undirected graph.
21.   **SearchElementAndRotatedArray.java**: Implement the search element and rotated array problem, which is based on the array.
22.   **Knapsack.java**: Implement the 0/1 Knapsack problem, which is based on dynamic programming.
23.   **Combinations.java**: Implement the combination that returns all possible combinations of k.
24.   **CloneGraph.java**: Implement a given reference of a node in a connected undirected graph.
25.   **MinStack.java**: Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.
26.   **CountAndSay.java**: Implement the count and say sequence of digit strings defined by the recursion formula.
27.   **CountFairPairs.java**: Implement a given 0-indexed integer array of size n and two integers, and return the number of fair pairs.
28.   **RabbitsInForest.java**: Implement a given  array of answers, return the minimum number of rabbits that could be in the forest.
29.   **CountHiddenSequence.java**: Implement the number of possible hidden sequences.
30.   **CountIdealArray.java**: Implement the number of distinct ideal arrays of length n.
31.   **CountLargestGroup.java**: Implement the number of groups that have the largest size.
32.   **CountCompleteSubArray.java**: Implement the subarray as a contiguous, non-empty part of an array.
33.   **CountInterestingSubArray.java**: Implement a method that returns an integer denoting the count of interesting subarrays.
34.   **ReorderList.java**: Implement  the given head of a singly linked list.
35.   **WordBreak.java**: The same word in the dictionary may be reused multiple times in the segmentation.
36.   **LRUCache.java**: Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.
37.   **InsertionSortList.java**: Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list's head.
38.   **ValidNumber.java**: Given a string s, return whether s is a valid number.
39.   **CompareVersionNumber.java**: To compare version strings, compare their revision values in left-to-right order. If one of the version strings has fewer revisions, treat the missing revision values as 0.
40.   **PushDominoes.java**: We will consider that a falling domino expends no additional force to a falling or already fallen domino.
41.   **SimplifyPath.java**: The task is to transform this absolute path into its simplified canonical path.
42.   **NoEquivalentPizza.java**: Return the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j].
43.   **TextJustification.java**: Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.
44.   **BuildArray.java**: Given a zero-based permutation nums (0-indexed), build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.
45.   **MinimumTime.java**: Return the minimum time to reach the room (n-1, m - 1).
46.   **MergeKSortedList.java**: Merge all the linked-lists into one sorted linked-list and return it.
47.   **RemoveElement.java**: Return the number of elements in nums that are not equal to val.
48.   **PlusOne.java**: Increment the large integer by one and return the resulting array of digits.
49.   **3ConsecutiveOdds.java**: Given an integer array arr, return true if there are three consecutive odd numbers in the array. Otherwise, return false.
50.   **3DigitEvenNo.java**: Given an integer array digits, where each element is a digit. The array may contain duplicates.
51.   **SwapNodePairs.java**: We must solve the problem without modifying the values in the list's nodes.
52.   **LongestValidParenthesis.java**: Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.
53.   **2Sum.java**: Given an array of integers nums and an integer target, return the indices of the two numbers such that they add up to target.
54.   **ZigZagConversion.java**: code that will take a string and make this conversion given a number of rows.
55.   **SortColors.java**: Solve this problem without using the library's sort function.
56.   **Permutations.java**: Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.
57.   **TypeOfTriangle.java**: Return a string representing the type of triangle that can be formed or "none" if it cannot form a triangle.
58.   **ZeroArrayTransformation.java: Return true if it is possible to transform nums into a Zero Array after processing all the queries sequentially, otherwise return false.
59.   **SetMatrixZero.java**: Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.
60.   **ZeroArrayTransform.java**: given an integer array nums of length n and a 2D array queries where queries[i] = [li, ri]
61.   **MaxSumNodValue.java**: Return the maximum possible sum of the values Alice can achieve by performing the operation any number of times.
62.   **FindWordsContainCharacter.java**: Return an array of indices representing the words that contain the character x.
63.   **LongestPalindrome.java**: Return the length of the longest palindrome that you can create. If it is impossible to create any palindrome, return 0.
64.   **LargestColorValue.java**: Return the largest colour value of any valid path in the given graph, or -1 if the graph contains a cycle.
65.   **ContainerWithWater.java**: Return the maximum amount of water a container can store.
66.   **NextPermutation.java**: A permutation of an array of integers is an arrangement of its members into a sequence or linear order.
67.   **3Sum.java**: Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
68.   **FindClosestNode.java**: Given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.
69.   **SnakeAndLadder.java**:  given an n x n integer matrix board where the cells are labelled from 1 to n2 in a Boustrophedon style starting from the bottom left of the board (i.e. board[n - 1][0]) and alternating direction each row.
70.   **DistributeCandies.java**: Return the total number of ways to distribute n candies among 3 children such that no child gets more than limit candies.
71.   **RunningSum.java**: Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]â€¦nums[i]).
72.   **MaximumCandies.java**: Given an integer array initialBoxes that contains the labels of the boxes we initially have. We can take all the candies in any open box, and we can use the keys in it to open new boxes, and we can also use the boxes we find in it.
73.   **SlidingWindowMax.java**: given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.
74.   **LexographicSmallString.java**: given two strings of the same length s1 and s2 and a string baseStr.
75.   **Permutations2.java**: Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.
76.   **SwapNode.java**: Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)
77.   **LexographicNumber.java**: Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.
78.   **KsmallLexographicOrder.java**: Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n].
79.   **MaxDiffEvenOdd.java**: To find the maximum difference.
80.   **GenerateParenthesis**: Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
81.   **MaxDiffAdjCircularArray.java**: Given a circular array nums, find the maximum absolute difference between adjacent elements.
82.   **MinMaxDiffPairs.java**: Return the minimum maximum difference among all p pairs. We define the maximum of an empty set to be zero.
83.   **MaxDiffRemappingDigit.java**: Return the difference between the maximum and minimum values Bob can make by remapping exactly one digit in num.
84.   **WildCardMatching.py**: The matching should cover the entire input string.
85.   **MaxDiffIncreasingElement.java**: Return the maximum difference. If no such i and j exist, return -1.
86.   **TrappingRainWater.java**: Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
87.   **DivideArrayToMaxDiff.java**: Return a 2D array containing the arrays. If it is impossible to satisfy the conditions, return an empty array. And if there are multiple answers, return any of them.
88.   **PartitionArrayMaxDiffK.java**: Given an integer array nums and an integer k. You may partition nums into one or more subsequences such that each element in nums appears in exactly one of the subsequences.
89.   **MaxManhattanDist.java**:  Find the maximum Manhattan distance from the origin that can be achieved at any time while performing the movements in order.
90.   **MinDelToMakeStringKSpecial**: Return the minimum number of characters you need to delete to make word k-special.
91.   **DivideStringGroupKSize.java**: Given the string s, the size of each group k and the character fill, return a string array denoting the composition of every group s has been divided into, using the above procedure.
92.   **SumKMirrorNumber.java**: Given the base k and the number n, return the sum of the n smallest k-mirror numbers.
93.   **KDistantIndicesArray.java**: Return a list of all k-distant indices sorted in increasing order.
94.   **KSmaalestSortedArray**: Given two sorted 0-indexed integer arrays nums1 and nums2 as well as an integer k, return the kth (1-based) smallest product of nums1[i] * nums2[j] where 0 <= i < nums1.length and 0 <= j < nums2.length.
95.   **LongestBinarySubsequence**: Return the length of the longest subsequence of s that makes up a binary number less than or equal to k.
96.   **LongestSubsequenceRepeatKTimes.java**: Return the longest subsequence repeated k times in string s. If multiple such subsequences are found, return the lexicographically largest one. If there is no such subsequence, return an empty string.
97.   **SubsequenceKWithLargestSum.java**: Return any such subsequence as an integer array of length k.
98.   **PalindromeNumber.java**: Given an integer x, return true if x is a palindrome, and false otherwise.
99.   **LongestHarmoniousSubsequence.java**: Given an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.
100.   **FindOriginalTypeString.java**: Return the total number of possible original strings that Alice might have intended to type.
101.   **3SumClosest.java**: Return the sum of the three integers.
102.   **FindKthCharacterStringGame.java**: Return the value of the kth character in word, after enough operations have been done for word to have at least k characters.
103.   **CountAndSay.java**: Given a positive integer n, return the nth element of the count-and-say sequence.
104.   **LuckyIntegerArray**: Return the largest lucky integer in the array. If there is no lucky integer, return -1.
105.   **FindingPairWithCertainSum.java**: Count the number of pairs (i, j) such that nums1[i] + nums2[j] equals a given value (0 <= i < nums1.length and 0 <= j < nums2.length).
106.   **MaximumNoEvents.java**: Return the maximum number of events you can attend.
107.   **LettersCombinations.java**: A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
108.   **RescehduleMeetings.java**: Return the maximum amount of free time possible after rearranging the meetings.
109.   **RegularExpressionMatching.java**: The matching should cover the entire input string (not partial).
110.   **MeetingRooms.java**: Return the number of the room that held the most meetings. If there are multiple rooms, return the room with the lowest number.
111.   **EarliestAndLatestRounds.java**: Given the integers n, firstPlayer, and secondPlayer, return an integer array containing two values, the earliest possible round number and the latest possible round number in which these two players will compete against each other, respectively.
112.   **MaximumMatchingPlayers.java**: Return the maximum number of matchings between players and trainers that satisfy these conditions.
113.   **ConvertBinaryNoLinkedList.java**: Return the decimal value of the number in the linked list.
114.   **ValidWord.java**: Return true if the word is valid, otherwise, return false.
115.   **MaximumLengthValidSubsequence.java**: A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.
116.   **DivideTwoIntegers.java**: Return the quotient after dividing dividend by divisor.
117.   **ReverseInteger.java**: Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.
118.   **RemoveSubFolders.java**: Given a list of folders folder, return the folders after removing all sub-folders in those folders. You may return the answer in any order.
119.   **DeleteDuplicateFolders**: Return the 2D array ans containing the paths of the remaining folders after deleting all the marked folders. The paths may be returned in any order.
120.   **DeleteCharactersToFancyString.java**: Return the final string after the deletion. It can be shown that the answer will always be unique.
121.   **MaximumErasureValue.java**: Return the maximum score you can get by erasing exactly one subarray.
122.   **MinimumScore.java**: Return the minimum score of any possible pair of edge removals on the given tree.
123.  **MaximumUniqueSubArray.java**: Return the maximum sum of such a subarray.
124.  **TwoSum.java**: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
125.  **CountAndValleys.java**: Return the number of hills and valleys in nums.
126.  **CountNumberBitwiseORSubsets.java**: The bitwise OR of an array a is equal to a[0] OR a[1] OR ... OR a[a.length - 1] (0-indexed).
127.  **SmallestSubArray.java**: Return an integer array answer of size n where answer[i] is the length of the minimum sized subarray starting at i with maximum bitwise OR.
128.  **LongestSubArray.java**: Return the length of the longest such subarray.
129.  **BitwiseORSubArray.java**: A subarray is a contiguous non-empty sequence of elements within an array.
130.  **PascalTriangle.java**: Given an integer numRows, return the first numRows of Pascal's triangle.
131.  **RearrangingFruits.java**: Return the minimum cost to make both the baskets equal or -1 if impossible.
132.  **ZigZagConversion.java**: The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows.
133.  **FruitsIntoBaskets.java**: Given the integer array fruits, return the maximum number of fruits you can pick.
134.  **FruitsInBaskets.java**: Return the number of fruit types that remain unplaced after all possible allocations are made.
135.  **ReverseString.java**: Write a function that reverses a string. The input string is given as an array of characters s.
136.  **MaxNoFruitCollect.java**: Return the maximum number of fruits the children can collect from the dungeon.
137.  **SoupServings.java**: Return the probability that A is used up before B, plus half the probability that both soups are used up in the same turn. Answers within 10-5 of the actual answer will be accepted.
138.  **PowerOfTwo.java**: An integer n is a power of two, if there exists an integer x such that n == 2x.
139.  **FibonacciNumber.java**: The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1.
140.  **PowerOfFour.java**: An integer n is a power of four, if there exists an integer x such that n == 4x.
141.  **Maximum69Number.java**: Return the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6).
142.  **New21Gaame.java**: Return the probability that Alice has n or fewer points.
143.  **24Game.java**: Return true if you can get such expression that evaluates to 24, and false otherwise.
144.  **NoFilledWithZeroSubArray.java**: A subarray is a contiguous non-empty sequence of elements within an array.
145.  **MinimumAreaToCover.java**: Return the minimum possible area of the rectangle.
146.  **MinimumAreaToCoverAll.java**: Return the minimum possible sum of the area of these rectangles.
147.  **LongestSubArrayOf1s.java**: Return the size of the longest non-empty subarray containing only 1's in the resulting array. Return 0 if there is no such subarray.
148.  **DiagonalTraverse.java**: Given an m x n matrix mat, return an array of all the elements of the array in a diagonal order.
149.  **RemoveElement.java**: Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.
150.  **LengthOfLongestVspaed.java**: Return the length of the longest V-shaped diagonal segment. If no valid segment exists, return 0.
151.  **SortMatrixByDiagonal.java**: The diagonals with a black arrow must be non-increasing, so [0, 2] is changed to [2, 0]. The other diagonals are already in the correct order.
152.  **AliceBobPlayingFlowerGame.java**: Return the number of possible pairs (x, y) that satisfy the conditions mentioned in the statement.
153.  **ValidSudoku.java**: Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
154.  **SudokuSolver.java**: program to solve a Sudoku puzzle by filling the empty cells.
155.  **MaximumAveragePassRatio.java**: Return the maximum possible average pass ratio after assigning the extraStudents students. Answers within 10-5 of the actual answer will be accepted.
156.  **NoWaysToPlacePeople.java**: given a 2D array points of size n x 2 representing integer coordinates of some points on a 2D plane, where points[i] = [xi, yi].
157.  **FirstMissingPositive.java**: Return the smallest positive integer that is not present in nums.
158.  *FindClosestPerson.java**: Both Person 1 and Person 2 move toward Person 3 at the same speed.
159.  **MinimumOperationsToMakeZero.java**: Return the integer denoting the minimum number of operations needed to make num1 equal to 0.
160.  **MinimumOperationsToMakeArrayZero.java**: determine the minimum number of operations required to reduce all elements of the array to zero for each query. Return the sum of the results for all queries.
161.  **NUniqueIntegerSum.java**: Given an integer n, return any array containing n unique integers such that they add up to 0.
162.  **MergeIntervals.java**: return an array of the non-overlapping intervals that cover all the intervals in the input.
163.  **NoOfPeopleAwareOfSecret.java**: Given an integer n, return the number of people who know the secret at the end of day n. Since the answer may be very large, return it modulo 109 + 7.
164.  **MinimumNoOfPeopleTeach.java**: choose one language and teach it to some users so that all friends can communicate with each other. Return the minimum number of users we need to teach.
165.  **SortVowelsInString.java**: The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in lowercase or uppercase. Consonants comprise all letters that are not vowels.
166.  **VowelsGameInString.java**: The first player who cannot make a move on their turn loses the game. We assume that both Alice and Bob play optimally.
167.  **MostFrequentVowelAndConsonant.java**: The frequency of a letter x is the number of times it occurs in the string.
168.  **VowelSpellChecker.java**: Given some queries, return a list of words, answer, where answer[i] is the correct word for query = queries[i].
169.  **MaxNoWordsCanType.java**: There is a malfunctioning keyboard where some letter keys do not work. All other keys on the keyboard work properly.
170.  **ReplaceNonCoPrimeNoArray.java**: Return the final modified array. It can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result.

 

 

 

 

 

## Contributing:

If you have additional algorithmic solutions or improvements to existing ones, feel free to contribute! Simply fork this repository, make your changes, and submit a pull request. Your contributions are highly appreciated!

## Feedback and Support:

If you have any feedback, suggestions, or questions regarding the solutions or this repository in general, please don't hesitate to open an issue. We're here to help and improve together!

Happy coding!

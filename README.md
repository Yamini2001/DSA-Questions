
# Java Algorithm Solutions

Welcome to the Java Algorithm Solutions repository! Here, you'll find Java implementations of various algorithmic problems, each aimed at enhancing your understanding of data structures, algorithms, and problem-solving skills.

## About This Repository:

This repository serves as a resource for programmers, students, and enthusiasts alike who are interested in learning and practicing algorithmic problem-solving using Java.

The solutions provided here cover a wide range of topics, including array manipulation, linked lists, string manipulation, searching, sorting, and more.

Feel free to explore the solutions, study the implementations, and use them as a reference for your own projects or academic pursuits.

## List of Files:

1. **ArrangeDuplicates.java**: Arrange duplicate elements in an array.
2. **DeleteKthNode.java**: Delete the k-th node from the end of a linked list.
3. **EvenFactPrime.java**: Find even factorial prime numbers.
4. **LongestCommonPrefix.java**: Find the longest common prefix among a set of strings.
5. **LRU_Cache.java**: Implement a Least Recently Used (LRU) cache.
6. **Moves_Zeroes.java**: Move zeroes to the end of an array while maintaining the order of non-zero elements.
7. **RemoveElement.java**: Remove all instances of a given value from an array in-place.
8. **ReverseList.java**: Reverse a singly linked list.
9. **ReverseString.java**: Reverse a given string.
10. **ReverseVowels.java**: Reverse only the vowels in a given string.
11. **SmallestMissingInteger.java**: Find the smallest positive integer missing from an unsorted array.
12. **Sqrt.java**: Find the square root of a given non-negative integer.
13. **Word_Search.java**: Implement the word search algorithm.
14. **Chocolate_Distribution.java**: Implement the chocolate distribution problem, which is based on Kadane's algorithm.
15. **LevelOrderTraversal.java**: Implement the chocolate distribution problem, which is based on a Binary Tree.
16. **DeleteMiddleElementofLinkedList.java**: Implement the delete the middle of element on the LinkedList problem, which is based on the Hare and Tortoise algorithm.
17. **FindMissingNumber.java**: Implement the Missing Number problem, which is based on the xor operation.
18.  **SumDependencyGraph.java**: Implement the sum dependencies problem, which is based on the directed and connected graphs.
19.   **StockBuyAndSell.java**: Implement the stock buy and sell problem, which is based on the array.
20.   **DetectCycleUndirectedGraph.java**: Implement the detect cycle undirected graph problem, which is based on an undirected graph.
21.   **SearchElementAndRotatedArray.java**: Implement the search element and rotated array problem, which is based on the array.
22.   **Knapsack.java**: Implement the 0/1 Knapsack problem, which is based on dynamic programming.
23.   **Combinations.java**: Implement the combination that returns all possible combinations of k.
24.   **CloneGraph.java**: Implement a given reference of a node in a connected undirected graph.
25.   **MinStack.java**: Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.
26.   **CountAndSay.java**: Implement the count and say sequence of digit strings defined by the recursion formula.
27.   **CountFairPairs.java**: Implement a given 0-indexed integer array of size n and two integers, and return the number of fair pairs.
28.   **RabbitsInForest.java**: Implement a given  array of answers, return the minimum number of rabbits that could be in the forest.
29.   **CountHiddenSequence.java**: Implement the number of possible hidden sequences.
30.   **CountIdealArray.java**: Implement the number of distinct ideal arrays of length n.
31.   **CountLargestGroup.java**: Implement the number of groups that have the largest size.
32.   **CountCompleteSubArray.java**: Implement the subarray as a contiguous, non-empty part of an array.
33.   **CountInterestingSubArray.java**: Implement a method that returns an integer denoting the count of interesting subarrays.
34.   **ReorderList.java**: Implement  the given head of a singly linked list.
35.   **WordBreak.java**: The same word in the dictionary may be reused multiple times in the segmentation.
36.   **LRUCache.java**: Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.
37.   **InsertionSortList.java**: Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list's head.
38.   **ValidNumber.java**: Given a string s, return whether s is a valid number.
39.   **CompareVersionNumber.java**: To compare version strings, compare their revision values in left-to-right order. If one of the version strings has fewer revisions, treat the missing revision values as 0.
40.   **PushDominoes.java**: We will consider that a falling domino expends no additional force to a falling or already fallen domino.
41.   **SimplifyPath.java**: The task is to transform this absolute path into its simplified canonical path.
42.   **NoEquivalentPizza.java**: Return the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j].
43.   **TextJustification.java**: Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.
44.   **BuildArray.java**: Given a zero-based permutation nums (0-indexed), build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.
45.   **MinimumTime.java**: Return the minimum time to reach the room (n-1, m - 1).
46.   **MergeKSortedList.java**: Merge all the linked-lists into one sorted linked-list and return it.
47.   **RemoveElement.java**: Return the number of elements in nums that are not equal to val.
48.   **PlusOne.java**: Increment the large integer by one and return the resulting array of digits.
49.   **3ConsecutiveOdds.java**: Given an integer array arr, return true if there are three consecutive odd numbers in the array. Otherwise, return false.
50.   **3DigitEvenNo.java**: Given an integer array digits, where each element is a digit. The array may contain duplicates.
51.   **SwapNodePairs.java**: We must solve the problem without modifying the values in the list's nodes.
52.   **LongestValidParenthesis.java**: Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.
53.   **2Sum.java**: Given an array of integers nums and an integer target, return the indices of the two numbers such that they add up to target.
54.   **ZigZagConversion.java**: code that will take a string and make this conversion given a number of rows.
55.   **SortColors.java**: Solve this problem without using the library's sort function.
56.   **Permutations.java**: Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.
57.   **TypeOfTriangle.java**: Return a string representing the type of triangle that can be formed or "none" if it cannot form a triangle.
58.   **ZeroArrayTransformation.java: Return true if it is possible to transform nums into a Zero Array after processing all the queries sequentially, otherwise return false.
59.   **SetMatrixZero.java**: Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.
60.   **ZeroArrayTransform.java**: given an integer array nums of length n and a 2D array queries where queries[i] = [li, ri]
61.   **MaxSumNodValue.java**: Return the maximum possible sum of the values Alice can achieve by performing the operation any number of times.
62.   **FindWordsContainCharacter.java**: Return an array of indices representing the words that contain the character x.
63.   **LongestPalindrome.java**: Return the length of the longest palindrome that you can create. If it is impossible to create any palindrome, return 0.
64.   **LargestColorValue.java**: Return the largest colour value of any valid path in the given graph, or -1 if the graph contains a cycle.
65.   **ContainerWithWater.java**: Return the maximum amount of water a container can store.
66.   **NextPermutation.java**: A permutation of an array of integers is an arrangement of its members into a sequence or linear order.
67.   **3Sum.java**: Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
68.   **FindClosestNode.java**: Given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.
69.   **SnakeAndLadder.java**:  given an n x n integer matrix board where the cells are labelled from 1 to n2 in a Boustrophedon style starting from the bottom left of the board (i.e. board[n - 1][0]) and alternating direction each row.
70.   **DistributeCandies.java**: Return the total number of ways to distribute n candies among 3 children such that no child gets more than limit candies.
71.   **RunningSum.java**: Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]â€¦nums[i]).
72.   **MaximumCandies.java**: Given an integer array initialBoxes that contains the labels of the boxes we initially have. We can take all the candies in any open box, and we can use the keys in it to open new boxes, and we can also use the boxes we find in it.
73.   **SlidingWindowMax.java**: given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.
74.   **LexographicSmallString.java**: given two strings of the same length s1 and s2 and a string baseStr.
75.   **Permutations2.java**: Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.
76.   **SwapNode.java**: Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)
77.   **LexographicNumber.java**: Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.
78.   **KsmallLexographicOrder.java**: Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n].
79.   **MaxDiffEvenOdd.java**: To find the maximum difference.
80.   **GenerateParenthesis**: Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
81.   **MaxDiffAdjCircularArray.java**: Given a circular array nums, find the maximum absolute difference between adjacent elements.
82.   **MinMaxDiffPairs.java**: Return the minimum maximum difference among all p pairs. We define the maximum of an empty set to be zero.
83.   **MaxDiffRemappingDigit.java**: Return the difference between the maximum and minimum values Bob can make by remapping exactly one digit in num.
84.   **WildCardMatching.py**: The matching should cover the entire input string.
85.   **MaxDiffIncreasingElement.java**: Return the maximum difference. If no such i and j exist, return -1.
86.   **TrappingRainWater.java**: Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
87.   **DivideArrayToMaxDiff.java**: Return a 2D array containing the arrays. If it is impossible to satisfy the conditions, return an empty array. And if there are multiple answers, return any of them.
88.   **PartitionArrayMaxDiffK.java**: Given an integer array nums and an integer k. You may partition nums into one or more subsequences such that each element in nums appears in exactly one of the subsequences.
89.   **MaxManhattanDist.java**:  Find the maximum Manhattan distance from the origin that can be achieved at any time while performing the movements in order.
90.   **MinDelToMakeStringKSpecial**: Return the minimum number of characters you need to delete to make word k-special.
91.   **DivideStringGroupKSize.java**: Given the string s, the size of each group k and the character fill, return a string array denoting the composition of every group s has been divided into, using the above procedure.
92.   **SumKMirrorNumber.java**: Given the base k and the number n, return the sum of the n smallest k-mirror numbers.
93.   **KDistantIndicesArray.java**: Return a list of all k-distant indices sorted in increasing order.
94.   **KSmaalestSortedArray**: Given two sorted 0-indexed integer arrays nums1 and nums2 as well as an integer k, return the kth (1-based) smallest product of nums1[i] * nums2[j] where 0 <= i < nums1.length and 0 <= j < nums2.length.

 

 



    
    

## Contributing:

If you have additional algorithmic solutions or improvements to existing ones, feel free to contribute! Simply fork this repository, make your changes, and submit a pull request. Your contributions are highly appreciated!

## Feedback and Support:

If you have any feedback, suggestions, or questions regarding the solutions or this repository in general, please don't hesitate to open an issue. We're here to help and improve together!

Happy coding!
